"""
Данная программа реализует статистику по банкам на основе данных в ЗПИФ-ЗД.
Программа состоит из функций:
stat - главная функция
menu и menu_date - вспомогательные функции интерфейса и обработкии введенных знанчений
В результате работы программа формирует в рабочей директории эксель-таблицу вида Ипотека "название банка" - "дата"
Локальная точка роста - настройка оформления через библиотеку xlsxwriter
Глобальная точка ротса - использовать в качестве исходных данных не ЗПИФ_ЗД, а 1С с помощью протокола OData
"""
import pandas as pd
import datetime


def stat(list_of_zhk, date, bank):
    res_li=[]
    li_digits=[]
    fio = []
    if bank == 'Ипотека ВТБ':  # Отдельный вариант для ВТБ
        for i in list_of_zhk:  # Цикл по всем ЗПИФ-ЗД
            try:
                df = pd.read_excel(i,
                                   parse_dates=True, header=[1], usecols=[5, 9, 10, 13, 17, 18, 20, 22], index_col=2)  # Чтение ЗПИФ_ЗД в датафрейм
                ipoteka_sber = df[(df['Способ оплаты'] == 'Ипотека Сбербанк')
                                  | (df['Способ оплаты'] == 'Военная ипотека Сбербанк')
                                  &(df['Примечание'] != 'Расторжение')][date]['Упрощенный способ оплаты'].count() # подсчет кол-ва договоров по Сберу за искомый период
                ipoteka_vtb = \
                df[(df['Способ оплаты'] == 'Ипотека ВТБ') | (df['Способ оплаты'] == 'Военная ипотека ВТБ')&(df['Примечание'] != 'Расторжение')][
                    date]['Упрощенный способ оплаты'].count()  # подсчет кол-ва договоров по ВТБ за искомый период
                ipoteka_total = df[(df['Упрощенный способ оплаты'] == 'ипотека') & (df['Примечание'] != 'Расторжение')][date]['Упрощенный способ оплаты'].count()
                # подсчет кол-ва договоров по всем банкам
                total = df[df['Примечание'] != 'Расторжение'][date]['Стоимость квартиры'].count()
                # подсчет кол-ва договоров всего за искомый период
                res_li.append((round(ipoteka_total/total, 2), round(ipoteka_vtb/ipoteka_total, 2), round(ipoteka_sber/ipoteka_total, 2)))
                #  Создаем списком кортежей с округленными долями ВТБ и Сбера
                df_digits = df[(df['Способ оплаты'] == 'Ипотека ВТБ')
                               | (df['Способ оплаты'] == 'Военная ипотека ВТБ')
                               & (df['Примечание'] != 'Расторжение')][date]
                # Создаем датафрейм по сделкам по ВТБ без расторжений
                li_digits.append((df_digits['Стоимость квартиры'].sum(), df_digits['Стоимость квартиры'].count()))
                # Из датафрейма по ВТБ выбираем сумму сделок и их количество
                fio.append(df_digits['ФИО клиента'])
                # В список с именами записываем имена клиентов из данных по ВТБ
            except KeyError:
                fio.append(None)
                li_digits.append((0, 0))
                res_li.append((0, 0, 0))
        df_shares = pd.DataFrame(res_li, columns=['Доля ипотечных продаж','Доля Ипотеки ВТБ в ипотечных продажах','Доля Ипотеки Сбербанка в ипотечных продажах'],
                                 index=['ЖК Май', 'ЖК Видный Берег', 'ЖК Новокрасково', 'ЖК Облака',
                                        'ЖК Дом на Барвихинской'])
        # Создаем датафрейм на основе списка кортежей res_li c долями ВТБ и Сбера (верхняя таблица)
        df_digits = pd.DataFrame(li_digits,columns=['Объем, руб.','Кол-во, шт.'], index=['ЖК Май', 'ЖК Видный Берег', 'ЖК Новокрасково', 'ЖК Облака', 'ЖК Дом на Барвихинской'])
        # Создаем датафрейм с цифрами по ВТБ (нижняя таблица)
        df_digits.loc['Итого'] = [df_digits['Объем, руб.'].sum(), df_digits['Кол-во, шт.'].sum()]
        # Добавляем строку ИТОГО в предыдущий датафрейм
        df_fio = pd.concat(fio)
        # Объединяем все списки с фамилиями клиентов по всем объектам в единый датафрейм
        return df_shares, df_digits, df_fio  # возвращаем кортеж датафреймов: доли ВТБ и Сбера (верхняя таблица), цифры по ВТБ(нижняя таблица), имена клиентов
    else:
        sales_total=[]
        for i in list_of_zhk:
            df = pd.read_excel(i,
                               parse_dates=True, header=[1], usecols=[5, 9, 10, 13, 17, 18, 20, 22], index_col=2)  #Чтение ЗПИФ_ЗД в датафрейм
            try:
                sales_total.append((df[df['Примечание'] != 'Расторжение'][date]['Стоимость квартиры'].count(),
                                    round(df[df['Примечание'] != 'Расторжение'][date]['Стоимость квартиры'].sum()/1000000,2),
                                   df[(df['Упрощенный способ оплаты'] == 'ипотека' )&(df['Примечание'] != 'Расторжение')][date]['Стоимость квартиры'].count(),
                                    round(df[(df['Упрощенный способ оплаты'] == 'ипотека')&(df['Примечание'] != 'Расторжение')][date]['Стоимость квартиры'].sum()/1000000,2),
                                    df[(df['Способ оплаты'] == bank) | (df['Способ оплаты'] == 'Военная ипотека ' + bank.split(' ')[1])
                                       &(df['Примечание'] != 'Расторжение')][date]['Стоимость квартиры'].count(),
                                    round(df[(df['Способ оплаты'] == bank) | (df['Способ оплаты'] == 'Военная ипотека ' + bank.split(' ')[1])
                                       &(df['Примечание'] != 'Расторжение')][date]['Стоимость квартиры'].sum()/1000000,2)))  #Создаем список кортежей следующего вида с данными без расторжений
                                                                                                                            #(всего кол-во сделок, всего объем сделок, кол-во кредитных сделок,
                                                                                                                            #объем кредитных сделок, кол-во и объем сделок по банку из параметра
            except KeyError:
                sales_total.append((0,0,0,0,0,0)) #Если на искомый месяц нет сделок, то записываем в список кортеж с нулями)
        df_sber = pd.DataFrame(sales_total,columns=['Всего сделок кол-во, шт.','Всего сделок объем, млн. руб.', #Создаем датафрейм на базе списка кортежей
                                                    'Кредитные сделки кол-во, шт.','Кредитные сделки объем, млн. руб.',
                                                    bank.split(' ')[1] + ' сделки кол-во, шт.',
                                                    bank.split(' ')[1] + ' сделки объем, млн. руб.'], index=['ЖК Май', 'ЖК Видный Берег', 'ЖК Новокрасково', 'ЖК Облака', 'ЖК Дом на Барвихинской'])
        df_sber.loc['Итого'] = [df_sber['Всего сделок кол-во, шт.'].sum(),
                                round(df_sber['Всего сделок объем, млн. руб.'].sum(),2),
                                df_sber['Кредитные сделки кол-во, шт.'].sum(),
                                round(df_sber['Кредитные сделки объем, млн. руб.'].sum(),2),
                                df_sber[bank.split(' ')[1] + ' сделки кол-во, шт.'].sum(),
                                round(df_sber[bank.split(' ')[1] + ' сделки объем, млн. руб.'].sum(),2)] #Добавляем строку ИТОГО в предыдущий датафрейм
        return df_sber


def menu():  # 1-я интерфейсная функция, которая обеспечивает ввод искомого банка
    while True:
        try:
            print('Выберите название банка: 1 - ВТБ, 2 - Сбербанк, 3 - Произвольный')
            var = int(input('>>'))
            if var == 1:
                return 'Ипотека ВТБ'
            elif var == 2:
                return 'Ипотека Сбербанк'
            elif var == 3:
                var = input('>>')
                return 'Ипотека ' + var
            else:
                print('Неверное знанчение, выберите 1, 2, или 3')
        except ValueError:
            print('Надо ввести цифру, а не что-то еще')


def menu_date():  # 2-я интерфейсная функция, которая обеспечивает ввод искомого месяца
    while True:
        try:
            print('Введите дату в формате ГГГГ-ММ')
            var = input('>>')
            if (2016 < int(var[:4]) <= datetime.datetime.now().year and 1 <= int(var[-2:]) < 13) or \
                    (int(var[:4]) == datetime.datetime.now().year and int(var[-2:]) <= datetime.datetime.now().month):
                return var  # В этом условии проверяем что год более, чем 2016, но не больше текущего, а если год текущий, то месяц не более текущего
            else:
                print('Дата некорректна')
        except ValueError:
            print('Неверное знанчение')


if __name__ == '__main__':
    bank = menu()
    print(bank)
    date = menu_date()
    list_of_zhk=['\\\\192.168.10.123\\юристы\\ЗПИФ_ЗД\\Рабочая\\_МАЙ_отчет продаж_.xlsx',
                 '\\\\192.168.10.123\\юристы\\ЗПИФ_ЗД\\Рабочая\\_Видный Берег_отчет продаж_.xlsx',
                 '\\\\192.168.10.123\\юристы\\ЗПИФ_ЗД\\Рабочая\\_Новокрасково_отчет продаж_.xlsx',
                 '\\\\192.168.10.123\\юристы\\ЗПИФ_ЗД\\Рабочая\\_ОБЛАКА_отчет продаж_.xlsx',
                 '\\\\192.168.10.123\\юристы\\ЗПИФ_ЗД\\Рабочая\\_Барвихинская_отчет продаж_.xlsx']
    tuple_answer = stat(list_of_zhk, date, bank)
    with pd.ExcelWriter(bank + "-" + date + '.xlsx') as writer:  # создаем файл для записии записываем каждый элемент кортежа
        workbook = writer.book
        if bank == 'Ипотека ВТБ':
            tuple_answer[0].to_excel(writer, sheet_name='Values', startrow=0)
            tuple_answer[1].to_excel(writer, sheet_name='Values', startrow=9)
            tuple_answer[2].to_excel(writer, sheet_name='Customers', index=False)
            worksheet = writer.sheets['Values']
            format1 = workbook.add_format({'num_format': '#,##0.00 ₽;#,##0.00 ₽'})
            format2 = workbook.add_format({'num_format': '0%', })
            for i in range (1,5):
                worksheet.set_row(i, None, format2)
            worksheet.set_column(0, 6, 33)
        else:
            tuple_answer.to_excel(writer, sheet_name='Values', startrow=0)
            worksheet = writer.sheets['Values']
            worksheet.set_column(0,6,33)

